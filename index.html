<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>BLASTEROIDS — Sharp Arcade Edition</title>
  <style>
    :root { --bg:#05070c; --fg:#b9f7ff; }
    html,body{
      height:100%; margin:0; background:var(--bg); color:var(--fg);
      font-family: ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;
    }
    #wrap{height:100%; display:flex; align-items:center; justify-content:center; padding:14px; box-sizing:border-box;}
    canvas{
      width:980px; height:720px;
      max-width:min(96vw,980px);
      max-height:min(86vh,720px);
      background: radial-gradient(1200px 700px at 50% 60%, rgba(20,36,64,.55), rgba(5,7,12,1));
      border:1px solid rgba(185,247,255,.18);
      border-radius:14px;
      box-shadow:0 18px 60px rgba(0,0,0,.55);
      image-rendering: crisp-edges;
      image-rendering: pixelated;
      touch-action:none;
    }
    #hint{
      position:fixed; left:0; right:0; bottom:10px; text-align:center;
      color: rgba(185,247,255,.7); font-size: 12px; letter-spacing:.2px;
      user-select:none; pointer-events:none;
    }
  </style>
</head>
<body>
<div id="wrap"><canvas id="c" width="980" height="720"></canvas></div>
<div id="hint">BLASTEROIDS — ←/→ rotate • ↑ thrust • Space shoot • Shift hyperspace • P pause • M mute</div>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha: true });

  const W = 980, H = 720;
  const TAU = Math.PI * 2;

  // ===== DPI (sharp)
  function setupDPI(){
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.style.width = W + "px";
    canvas.style.height = H + "px";
    canvas.width = Math.floor(W * dpr);
    canvas.height = Math.floor(H * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    ctx.imageSmoothingEnabled = false; // key for crispness
  }
  setupDPI();
  window.addEventListener("resize", setupDPI);

  // ===== Helpers
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const rand  = (a,b)=>a+Math.random()*(b-a);
  const wrap  = (p)=>{ if(p.x<0)p.x+=W; else if(p.x>=W)p.x-=W; if(p.y<0)p.y+=H; else if(p.y>=H)p.y-=H; };
  const dist2 = (ax,ay,bx,by)=>{ const dx=ax-bx, dy=ay-by; return dx*dx+dy*dy; };

  // ===== Tiny audio
  let muted = false;
  const AudioCtx = window.AudioContext || window.webkitAudioContext;
  const audio = AudioCtx ? new AudioCtx() : null;

  function beep(freq=440, dur=0.06, type="square", gain=0.05){
    if(!audio || muted) return;
    if(audio.state === "suspended") audio.resume().catch(()=>{});
    const o = audio.createOscillator();
    const g = audio.createGain();
    o.type = type;
    o.frequency.value = freq;
    g.gain.value = gain;
    o.connect(g); g.connect(audio.destination);
    const t = audio.currentTime;
    g.gain.setValueAtTime(gain, t);
    g.gain.exponentialRampToValueAtTime(0.0001, t + dur);
    o.start(t);
    o.stop(t + dur + 0.02);
  }

  // ===== Input
  const keys = new Set();
  window.addEventListener("keydown", (e) => {
    if(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"," "].includes(e.key)) e.preventDefault();

    // Press SPACE to start from splash
    if(showSplash && e.key === " "){
      showSplash = false;
      state.level = 1;
      state.lives = 3;
      state.score = 0;
      resetShip();
      nextStage();
      beep(784,0.06,"square",0.05);
      return;
    }

    keys.add(e.key);

    if(e.key === "p" || e.key === "P") togglePause();
    if(e.key === "m" || e.key === "M") { muted = !muted; beep(muted?160:660, 0.08, "square", 0.05); }
    if(e.key === "Shift") tryHyperspace();
  }, {passive:false});
  window.addEventListener("keyup", (e) => keys.delete(e.key));
  canvas.addEventListener("pointerdown", () => { if(audio && audio.state==="suspended") audio.resume().catch(()=>{}); });

  // ===== State
  const state = {
    paused:false,
    score:0,
    hi:Number(localStorage.getItem("blasteroids_hi")||0),
    level:1,
    lives:3,
    shake:0,
    time:0,
    mode:"splash", // splash | wave | boss
    bannerT:0
  };

  const ship = {
    x:W/2,y:H/2,vx:0,vy:0,a:-Math.PI/2,r:12,
    invuln:2.0,thrust:0,cooldown:0,rapidUntil:0
  };

  let bullets=[], rocks=[], enemies=[], powerups=[], particles=[], boss=null;
  let showSplash = true;

  // ===== Stars (no blur, crisp points)
  const stars = (() => {
    const s=[];
    for(let i=0;i<170;i++){
      s.push({x:Math.random()*W, y:Math.random()*H, z:Math.random(), s:Math.random()<0.12?2:1});
    }
    return s;
  })();

  // ===== Particles
  function burst(x,y,color="rgba(185,247,255,.9)", n=18, sp=140){
    for(let i=0;i<n;i++){
      const a = rand(0,TAU);
      const v = rand(sp*0.35, sp);
      particles.push({x,y,vx:Math.cos(a)*v,vy:Math.sin(a)*v,t:0,life:rand(0.25,0.75),color});
    }
  }

  // ===== Rocks (vector-like polygons)
  function makeRock(x,y,size=3, comet=false){
    const rBase = comet ? 14 : (size===3?46 : size===2?28 : 16);
    const pts=[];
    const n = Math.floor(rand(comet?7:9, comet?10:14));
    for(let i=0;i<n;i++){
      const ang = (i/n)*TAU;
      const jitter = rand(0.70, 1.12);
      pts.push({x:Math.cos(ang)*rBase*jitter, y:Math.sin(ang)*rBase*jitter});
    }
    const speed = comet ? rand(220, 320) : (size===3?rand(18,42):size===2?rand(30,64):rand(50,92));
    const ang = rand(0,TAU);
    return {x,y,vx:Math.cos(ang)*speed,vy:Math.sin(ang)*speed,a:rand(0,TAU),av:rand(-1.0,1.0),size,r:rBase,pts,comet};
  }

  function spawnComet(){
    const side = Math.random()<0.5 ? -40 : W+40;
    const x = side;
    const y = rand(40,H-40);
    const ang = Math.atan2(ship.y-y, ship.x-x) + rand(-0.35,0.35);
    const speed = rand(240, 360);
    const r = makeRock(x,y,1,true);
    r.vx = Math.cos(ang)*speed;
    r.vy = Math.sin(ang)*speed;
    r.av = rand(-2.6,2.6);
    return r;
  }

  function breakRock(idx, quiet=false){
    const r = rocks[idx];
    rocks.splice(idx,1);
    burst(r.x,r.y,"rgba(185,247,255,.95)", r.size===3?22:r.size===2?16:12, r.comet?240:160);
    if(!quiet) beep(r.size===3?240:r.size===2?320:420, 0.06, "square", 0.05);

    state.score += r.comet ? 140 : (r.size===3?20:r.size===2?50:100);
    if(!r.comet && r.size<=2 && Math.random()<0.10) dropPowerup(r.x,r.y);

    if(!r.comet && r.size>1){
      const s=r.size-1;
      for(let k=0;k<2;k++){
        const nr = makeRock(r.x+rand(-8,8), r.y+rand(-8,8), s);
        nr.vx += r.vx*0.35; nr.vy += r.vy*0.35;
        rocks.push(nr);
      }
    }
    state.shake = Math.min(0.22, state.shake + (r.comet?0.10:0.06));
  }

  // ===== Powerups
  function dropPowerup(x,y){
    const kind = Math.random()<0.55 ? "rapid" : "shield";
    powerups.push({x,y,vx:rand(-25,25),vy:rand(-25,25),r:12,kind,t:0});
  }

  // ===== Enemies (3 types + boss adds)
  function spawnSaucer(){
    const side = Math.random()<0.5 ? -40 : W+40;
    return {kind:"saucer",x:side,y:rand(90,H-90),vx:side<0?rand(70,120):-rand(70,120),vy:rand(-22,22),t:0,r:16,fire:rand(0.6,1.25),hp:2};
  }
  function spawnDrone(){
    const edge = Math.floor(rand(0,4));
    const pos = [
      {x:rand(0,W),y:-30},
      {x:W+30,y:rand(0,H)},
      {x:rand(0,W),y:H+30},
      {x:-30,y:rand(0,H)}
    ][edge];
    return {kind:"drone",x:pos.x,y:pos.y,vx:0,vy:0,t:0,r:14,hp:3,dash:rand(0.7,1.5)};
  }
  function spawnMine(){
    let x,y;
    for(let tries=0;tries<60;tries++){
      x=Math.random()*W; y=Math.random()*H;
      if(dist2(x,y,ship.x,ship.y) > 220*220) break;
    }
    return {kind:"mine",x,y,vx:rand(-28,28),vy:rand(-28,28),t:0,r:16,hp:2,arm:1.3};
  }
  function explodeMine(m){
    burst(m.x,m.y,"rgba(255,209,102,.95)",22,190);
    state.shake = Math.min(0.32, state.shake + 0.16);
    beep(260,0.08,"sawtooth",0.05);
    const n=10;
    for(let i=0;i<n;i++){
      const a=(i/n)*TAU + rand(-0.15,0.15);
      bullets.push({x:m.x,y:m.y,vx:Math.cos(a)*320,vy:Math.sin(a)*320,life:1.1,t:0,r:2,friendly:false,dmg:1});
    }
    if(dist2(m.x,m.y,ship.x,ship.y) < (m.r+34)**2) hitShip();
  }

  // ===== Bullets
  function enemyShoot(x,y,tx,ty, speed=360, spread=0.25){
    const a = Math.atan2(ty-y, tx-x) + rand(-spread, spread);
    bullets.push({x,y,vx:Math.cos(a)*speed,vy:Math.sin(a)*speed,life:1.35,t:0,r:2,friendly:false,dmg:1});
    beep(330,0.05,"sawtooth",0.03);
  }

  // ===== Boss (every 5 levels)
  function spawnBoss(level){
    const hp = 36 + level*8;
    return {x:W/2,y:120,vx:120,t:0,hp,maxHp:hp,r:58,fireA:0.55,fireB:1.25,coreOpen:0,coreCycle:3.4,nextCore:2.2};
  }
  const isBossLevel = (lvl)=>lvl%5===0;
  const bossCoreOpen = (b)=>b && b.coreOpen>0;

  // ===== Stage setup
  function resetShip(){
    ship.x=W/2; ship.y=H/2; ship.vx=0; ship.vy=0; ship.a=-Math.PI/2;
    ship.invuln=2.0; ship.thrust=0; ship.cooldown=0;
  }

  function startWave(level){
    state.mode="wave";
    rocks=[]; enemies=[]; bullets=[]; powerups=[];
    const big = Math.min(7, 3 + Math.floor(level*0.75));
    for(let i=0;i<big;i++){
      let x,y;
      for(let tries=0;tries<50;tries++){
        x=Math.random()*W; y=Math.random()*H;
        if(dist2(x,y,ship.x,ship.y) > 180*180) break;
      }
      rocks.push(makeRock(x,y,3,false));
    }
    boss=null;
    state.bannerT=1.5;
  }

  function startBossRound(level){
    state.mode="boss";
    rocks=[]; enemies=[]; bullets=[]; powerups=[];
    boss = spawnBoss(level);
    state.bannerT=2.0;
    beep(523,0.09,"square",0.06); beep(392,0.09,"square",0.06); beep(262,0.12,"square",0.06);
  }

  function nextStage(){
    if(isBossLevel(state.level)) startBossRound(state.level);
    else startWave(state.level);
    beep(523,0.06,"square",0.04); beep(784,0.06,"square",0.04);
  }

  // ===== Pause/hyperspace/death
  function togglePause(){ state.paused = !state.paused; beep(state.paused?200:600,0.06,"square",0.035); }

  function tryHyperspace(){
    if(showSplash || state.paused) return;
    beep(1100,0.05,"square",0.03);
    if(Math.random()<0.12){ hitShip(); return; }
    let x,y;
    for(let tries=0;tries<50;tries++){
      x=Math.random()*W; y=Math.random()*H;
      let ok=true;
      for(const r of rocks) if(dist2(x,y,r.x,r.y) < (r.r+70)**2){ ok=false; break; }
      if(boss && dist2(x,y,boss.x,boss.y) < (boss.r+110)**2) ok=false;
      if(ok) break;
    }
    ship.x=x; ship.y=y; ship.vx*=0.25; ship.vy*=0.25;
    ship.invuln=Math.max(ship.invuln,0.8);
    burst(ship.x,ship.y,"rgba(127,255,212,.95)",14,130);
  }

  function hitShip(){
    if(ship.invuln>0) return;
    state.lives -= 1;
    state.shake = 0.30;
    burst(ship.x,ship.y,"rgba(255,77,109,.95)",22,170);
    beep(140,0.10,"sawtooth",0.06); beep(90,0.10,"sawtooth",0.05);

    if(state.lives<=0){
      state.hi = Math.max(state.hi, state.score);
      localStorage.setItem("blasteroids_hi", String(state.hi));
      // back to splash on game over
      state.score=0; state.level=1; state.lives=3;
      bullets=[]; rocks=[]; enemies=[]; powerups=[]; particles=[]; boss=null;
      resetShip();
      state.mode="splash";
      showSplash=true;
    } else {
      resetShip();
    }
  }

  // ===== Vector draw helper (crisp, no blur)
  function vstroke(color, width, pathFn){
    ctx.save();
    ctx.strokeStyle = color;
    ctx.lineWidth = width;
    ctx.lineJoin = "round";
    ctx.lineCap = "round";
    ctx.beginPath();
    pathFn();
    ctx.stroke();
    ctx.restore();
  }

  // ===== Main update
  function update(dt){
    state.time += dt;

    // stars
    for(const s of stars){
      s.y += (10 + s.z*34)*dt;
      if(s.y > H+4){ s.y=-4; s.x=Math.random()*W; }
    }

    // particles
    for(let i=particles.length-1;i>=0;i--){
      const p=particles[i];
      p.t += dt; p.x += p.vx*dt; p.y += p.vy*dt;
      p.vx *= Math.pow(0.88, dt*60);
      p.vy *= Math.pow(0.88, dt*60);
      if(p.t>=p.life) particles.splice(i,1);
    }

    if(showSplash) return;

    state.bannerT = Math.max(0, state.bannerT - dt);

    // ship
    ship.invuln = Math.max(0, ship.invuln - dt);
    ship.cooldown = Math.max(0, ship.cooldown - dt);
    ship.thrust = 0;

    const rot = 3.2;
    if(keys.has("ArrowLeft")) ship.a -= rot*dt;
    if(keys.has("ArrowRight")) ship.a += rot*dt;

    if(keys.has("ArrowUp")){
      const acc = 260;
      ship.vx += Math.cos(ship.a)*acc*dt;
      ship.vy += Math.sin(ship.a)*acc*dt;
      ship.thrust=1;
      if(Math.random()<0.30){
        particles.push({
          x: ship.x - Math.cos(ship.a)*16 + rand(-1,1),
          y: ship.y - Math.sin(ship.a)*16 + rand(-1,1),
          vx: ship.vx - Math.cos(ship.a)*rand(80,160),
          vy: ship.vy - Math.sin(ship.a)*rand(80,160),
          t:0, life:rand(0.12,0.22),
          color:"rgba(255,209,102,.9)"
        });
      }
    }

    const maxV=340;
    const sp=Math.hypot(ship.vx,ship.vy);
    if(sp>maxV){ ship.vx = ship.vx/sp*maxV; ship.vy = ship.vy/sp*maxV; }

    ship.x += ship.vx*dt; ship.y += ship.vy*dt; wrap(ship);

    // fire
    const rapid = state.time < ship.rapidUntil;
    const fireDelay = rapid ? 0.10 : 0.18;
    if(keys.has(" ") && ship.cooldown<=0){
      ship.cooldown=fireDelay;
      const mx = ship.x + Math.cos(ship.a)*16;
      const my = ship.y + Math.sin(ship.a)*16;
      const inherit=0.35;
      bullets.push({x:mx,y:my,vx:Math.cos(ship.a)*560 + ship.vx*inherit,vy:Math.sin(ship.a)*560 + ship.vy*inherit,life:1.0,t:0,r:2,friendly:true,dmg:1});
      beep(rapid?980:880,0.035,"square",0.04);
    }

    // bullets
    for(let i=bullets.length-1;i>=0;i--){
      const b=bullets[i];
      b.t += dt;
      b.x += b.vx*dt; b.y += b.vy*dt; wrap(b);
      if(b.t>=b.life) bullets.splice(i,1);
    }

    // powerups
    for(let i=powerups.length-1;i>=0;i--){
      const p=powerups[i];
      p.t += dt; p.x += p.vx*dt; p.y += p.vy*dt;
      p.vx *= Math.pow(0.92, dt*60); p.vy *= Math.pow(0.92, dt*60);
      wrap(p);
      if(dist2(p.x,p.y,ship.x,ship.y) < (p.r+ship.r+6)**2){
        if(p.kind==="rapid"){ ship.rapidUntil = state.time + 8.0; beep(1047,0.06,"square",0.05); }
        else { ship.invuln = Math.max(ship.invuln, 6.0); beep(740,0.07,"triangle",0.05); }
        burst(p.x,p.y,"rgba(127,255,212,.95)",14,140);
        powerups.splice(i,1);
      }
      if(p.t>12) powerups.splice(i,1);
    }

    if(state.mode==="wave"){
      for(const r of rocks){ r.a += r.av*dt; r.x += r.vx*dt; r.y += r.vy*dt; wrap(r); }

      const threat = Math.min(1.0, 0.25 + state.level*0.06);
      const saucerRate = clamp(0.004 + state.level*0.0014, 0.004, 0.014);
      const droneRate  = clamp(0.0025 + state.level*0.0011, 0.0025, 0.010);
      const mineRate   = clamp(0.0016 + state.level*0.0009, 0.0016, 0.008);
      const cometRate  = clamp(0.0015 + state.level*0.0008, 0.0015, 0.008);

      if(Math.random() < saucerRate*dt && enemies.filter(e=>e.kind==="saucer").length<1) enemies.push(spawnSaucer());
      if(Math.random() < droneRate*dt  && enemies.filter(e=>e.kind==="drone").length < Math.floor(1+threat)) enemies.push(spawnDrone());
      if(Math.random() < mineRate*dt   && enemies.filter(e=>e.kind==="mine").length  < Math.floor(1+threat)) enemies.push(spawnMine());
      if(Math.random() < cometRate*dt  && rocks.filter(r=>r.comet).length < Math.floor(1+threat)) rocks.push(spawnComet());

      for(let i=enemies.length-1;i>=0;i--){
        const e=enemies[i];
        e.t += dt;

        if(e.kind==="saucer"){
          e.x += e.vx*dt; e.y += e.vy*dt;
          if(e.y<60 || e.y>H-60) e.vy *= -1;
          if(e.x<-90 || e.x>W+90){ enemies.splice(i,1); continue; }
          e.fire -= dt;
          if(e.fire<=0){ e.fire=rand(0.65,1.35); enemyShoot(e.x,e.y,ship.x,ship.y,360,0.26); }
        }

        if(e.kind==="drone"){
          const ax=ship.x-e.x, ay=ship.y-e.y;
          const d=Math.hypot(ax,ay)||1;
          const seek=120;
          e.vx += (ax/d)*seek*dt; e.vy += (ay/d)*seek*dt;
          e.dash -= dt;
          if(e.dash<=0){ e.dash=rand(0.9,1.7); e.vx += (ax/d)*180; e.vy += (ay/d)*180; beep(520,0.03,"square",0.02); }
          const sp2=Math.hypot(e.vx,e.vy);
          const cap=220;
          if(sp2>cap){ e.vx=e.vx/sp2*cap; e.vy=e.vy/sp2*cap; }
          e.x += e.vx*dt; e.y += e.vy*dt; wrap(e);
          if(d>220 && Math.random()<0.35*dt) enemyShoot(e.x,e.y,ship.x,ship.y,300,0.18);
        }

        if(e.kind==="mine"){
          e.arm = Math.max(0, e.arm - dt);
          e.x += e.vx*dt; e.y += e.vy*dt;
          e.vx *= Math.pow(0.985, dt*60); e.vy *= Math.pow(0.985, dt*60);
          wrap(e);
          if(e.arm<=0 && dist2(e.x,e.y,ship.x,ship.y) < (e.r+70)**2){
            explodeMine(e);
            enemies.splice(i,1);
            continue;
          }
        }
      }

      if(rocks.length===0 && enemies.length===0){
        state.level += 1;
        resetShip();
        nextStage();
      }
    } else if(boss){
      boss.t += dt;
      boss.x += boss.vx*dt;
      if(boss.x<120){ boss.x=120; boss.vx*=-1; }
      if(boss.x>W-120){ boss.x=W-120; boss.vx*=-1; }
      boss.y = 110 + Math.sin(boss.t*0.9)*22;

      boss.nextCore -= dt;
      if(boss.nextCore<=0){ boss.coreOpen=1.35; boss.nextCore=boss.coreCycle; beep(740,0.05,"triangle",0.04); }
      boss.coreOpen = Math.max(0, boss.coreOpen - dt);

      boss.fireA -= dt;
      if(boss.fireA<=0){
        boss.fireA = clamp(0.50 - state.level*0.01, 0.26, 0.50);
        enemyShoot(boss.x-34,boss.y+18,ship.x,ship.y,380,0.16);
        enemyShoot(boss.x+34,boss.y+18,ship.x,ship.y,380,0.16);
      }

      const hpFrac = boss.hp / boss.maxHp;
      boss.fireB -= dt;
      if(boss.fireB<=0){
        boss.fireB = clamp(1.35 - (1-hpFrac)*0.65, 0.65, 1.35);
        const base = Math.atan2(ship.y-boss.y, ship.x-boss.x);
        const spread = clamp(0.55 - hpFrac*0.25, 0.30, 0.55);
        const shots = hpFrac < 0.45 ? 9 : 7;
        for(let i=0;i<shots;i++){
          const t=(i-(shots-1)/2)/((shots-1)/2);
          const a=base + t*spread + Math.sin(boss.t*1.2)*0.12;
          bullets.push({x:boss.x,y:boss.y+28,vx:Math.cos(a)*320,vy:Math.sin(a)*320,life:1.35,t:0,r:2,friendly:false,dmg:1});
        }
        beep(240,0.06,"sawtooth",0.04);
      }

      if(hpFrac<0.66 && enemies.length<2 && Math.random()<0.24*dt) enemies.push(spawnDrone());
      if(hpFrac<0.40 && enemies.filter(e=>e.kind==="mine").length<1 && Math.random()<0.16*dt) enemies.push(spawnMine());

      for(let i=enemies.length-1;i>=0;i--){
        const e=enemies[i];
        e.t += dt;
        if(e.kind==="drone"){
          const ax=ship.x-e.x, ay=ship.y-e.y;
          const d=Math.hypot(ax,ay)||1;
          const seek=130;
          e.vx += (ax/d)*seek*dt; e.vy += (ay/d)*seek*dt;
          e.dash -= dt;
          if(e.dash<=0){ e.dash=rand(0.9,1.6); e.vx += (ax/d)*190; e.vy += (ay/d)*190; }
          const sp2=Math.hypot(e.vx,e.vy);
          const cap=240;
          if(sp2>cap){ e.vx=e.vx/sp2*cap; e.vy=e.vy/sp2*cap; }
          e.x += e.vx*dt; e.y += e.vy*dt; wrap(e);
          if(d>220 && Math.random()<0.35*dt) enemyShoot(e.x,e.y,ship.x,ship.y,310,0.18);
        }
        if(e.kind==="mine"){
          e.arm = Math.max(0, e.arm - dt);
          e.x += e.vx*dt; e.y += e.vy*dt;
          e.vx *= Math.pow(0.985, dt*60); e.vy *= Math.pow(0.985, dt*60);
          wrap(e);
          if(e.arm<=0 && dist2(e.x,e.y,ship.x,ship.y) < (e.r+70)**2){
            explodeMine(e);
            enemies.splice(i,1);
            continue;
          }
        }
      }

      if(boss.hp<=0){
        state.score += 1200 + state.level*80;
        burst(boss.x,boss.y,"rgba(255,77,109,.95)",40,240);
        state.shake=0.40;
        if(Math.random()<0.6) dropPowerup(boss.x,boss.y);
        boss=null;
        state.level += 1;
        resetShip();
        nextStage();
      }
    }

    // collisions
    for(const r of rocks){
      if(dist2(ship.x,ship.y,r.x,r.y) < (ship.r + r.r*0.9)**2){ hitShip(); break; }
    }
    for(const e of enemies){
      if(dist2(ship.x,ship.y,e.x,e.y) < (ship.r + e.r + 6)**2){
        if(e.kind==="mine" && e.arm<=0.3) explodeMine(e);
        hitShip(); break;
      }
    }
    if(boss && dist2(ship.x,ship.y,boss.x,boss.y) < (ship.r + boss.r + 18)**2) hitShip();

    // ship vs enemy bullets
    for(let i=bullets.length-1;i>=0;i--){
      const b=bullets[i];
      if(b.friendly) continue;
      if(dist2(ship.x,ship.y,b.x,b.y) < (ship.r + b.r + 3)**2){
        bullets.splice(i,1);
        hitShip();
        break;
      }
    }

    // friendly bullets hit
    for(let i=bullets.length-1;i>=0;i--){
      const b=bullets[i];
      if(!b.friendly) continue;

      let hit=false;

      for(let j=rocks.length-1;j>=0;j--){
        const r=rocks[j];
        if(dist2(b.x,b.y,r.x,r.y) < (r.r)**2){
          bullets.splice(i,1);
          breakRock(j);
          hit=true;
          break;
        }
      }
      if(hit) continue;

      for(let j=enemies.length-1;j>=0;j--){
        const e=enemies[j];
        if(dist2(b.x,b.y,e.x,e.y) < (e.r+6)**2){
          bullets.splice(i,1);
          e.hp -= b.dmg;
          burst(b.x,b.y,"rgba(255,209,102,.9)",10,140);
          beep(520,0.04,"square",0.035);
          if(e.hp<=0){
            burst(e.x,e.y,"rgba(255,77,109,.95)",20,180);
            state.score += (e.kind==="drone"?180 : e.kind==="mine"?160 : 250);
            if(Math.random()<0.22) dropPowerup(e.x,e.y);
            enemies.splice(j,1);
          }
          hit=true;
          break;
        }
      }
      if(hit) continue;

      if(boss){
        const hullR = boss.r + 22;
        if(dist2(b.x,b.y,boss.x,boss.y) < hullR*hullR){
          bullets.splice(i,1);
          const coreX=boss.x, coreY=boss.y+10, coreR=18;
          const open = bossCoreOpen(boss);
          const dCore = dist2(b.x,b.y,coreX,coreY);

          let dmg=1;
          if(open && dCore < coreR*coreR){ dmg=2; burst(b.x,b.y,"rgba(127,255,212,.95)",12,150); beep(980,0.03,"square",0.03); }
          else burst(b.x,b.y,"rgba(185,247,255,.9)",8,120);

          boss.hp -= dmg;
          state.score += open ? 25 : 10;
          state.shake = Math.min(0.28, state.shake + (open?0.05:0.03));
        }
      }
    }

    if(state.score > state.hi){
      state.hi = state.score;
      localStorage.setItem("blasteroids_hi", String(state.hi));
    }
  }

  // ===== Draw
  function draw(){
    ctx.clearRect(0,0,W,H);

    // mild shake
    const shake = state.shake;
    const sx = shake ? rand(-12,12)*shake : 0;
    const sy = shake ? rand(-12,12)*shake : 0;
    ctx.save();
    ctx.translate(sx, sy);

    // stars
    ctx.fillStyle = "rgba(185,247,255,.7)";
    for(const s of stars){
      ctx.globalAlpha = 0.25 + s.z*0.55;
      ctx.fillRect((s.x|0), (s.y|0), s.s, s.s);
    }
    ctx.globalAlpha = 1;

    // subtle grid (crisp)
    ctx.strokeStyle = "rgba(185,247,255,.04)";
    ctx.lineWidth = 1;
    for(let x=0;x<=W;x+=70){ ctx.beginPath(); ctx.moveTo(x+0.5,0); ctx.lineTo(x+0.5,H); ctx.stroke(); }
    for(let y=0;y<=H;y+=70){ ctx.beginPath(); ctx.moveTo(0,y+0.5); ctx.lineTo(W,y+0.5); ctx.stroke(); }

    // particles
    for(const p of particles){
      const a = 1 - (p.t/p.life);
      ctx.globalAlpha = clamp(a,0,1);
      ctx.fillStyle = p.color;
      ctx.fillRect(p.x|0, p.y|0, 2, 2);
    }
    ctx.globalAlpha = 1;

    // Splash (with basic play instructions)
    if(showSplash){
      ctx.save();
      ctx.fillStyle="rgba(0,0,0,.62)";
      ctx.fillRect(0,0,W,H);

      ctx.textAlign="center";
      ctx.textBaseline="middle";

      ctx.fillStyle="rgba(185,247,255,.98)";
      ctx.font="68px ui-monospace, monospace";
      ctx.fillText("BLASTEROIDS", W/2, H*0.34);

      ctx.fillStyle="rgba(185,247,255,.78)";
      ctx.font="20px ui-monospace, monospace";
      ctx.fillText("PRESS SPACE TO START", W/2, H*0.44);

      // Controls
      ctx.fillStyle="rgba(185,247,255,.72)";
      ctx.font="15px ui-monospace, monospace";
      ctx.fillText("CONTROLS", W/2, H*0.52);

      ctx.font="14px ui-monospace, monospace";
      ctx.fillStyle="rgba(185,247,255,.65)";
      const lines = [
        "←/→  Rotate",
        "↑     Thrust",
        "Space Shoot",
        "Shift Hyperspace",
        "P     Pause   •   M Mute"
      ];
      let y = H*0.56;
      for(const t of lines){ ctx.fillText(t, W/2, y); y += 18; }

      // How to play
      ctx.fillStyle="rgba(255,209,102,.80)";
      ctx.font="15px ui-monospace, monospace";
      ctx.fillText("HOW TO PLAY", W/2, H*0.72);

      ctx.fillStyle="rgba(255,209,102,.70)";
      ctx.font="14px ui-monospace, monospace";
      const how = [
        "Shoot asteroids to score — big rocks split into smaller ones.",
        "Avoid enemy fire (saucers, drones, mines).",
        "Collect powerups: R = Rapid Fire, S = Shield.",
        "Boss round every 5 levels."
      ];
      y = H*0.76;
      for(const t of how){ ctx.fillText(t, W/2, y); y += 18; }

      ctx.restore();
      ctx.restore();
      return;
    }

    // rocks
    for(const r of rocks){
      ctx.save();
      ctx.translate(r.x, r.y);
      ctx.rotate(r.a);
      const col = r.comet ? "rgba(255,209,102,.95)" : "rgba(185,247,255,.95)";
      vstroke(col, 2, () => {
        const pts=r.pts;
        ctx.moveTo(pts[0].x, pts[0].y);
        for(let i=1;i<pts.length;i++) ctx.lineTo(pts[i].x, pts[i].y);
        ctx.closePath();
      });
      ctx.restore();
    }

    // enemies
    for(const e of enemies){
      if(e.kind==="saucer"){
        vstroke("rgba(255,209,102,.95)",2,()=>{
          ctx.moveTo(e.x-18,e.y);
          ctx.lineTo(e.x-8,e.y-6);
          ctx.lineTo(e.x+8,e.y-6);
          ctx.lineTo(e.x+18,e.y);
          ctx.lineTo(e.x+8,e.y+6);
          ctx.lineTo(e.x-8,e.y+6);
          ctx.closePath();
        });
      }
      if(e.kind==="drone"){
        const a=Math.atan2(e.vy,e.vx);
        vstroke("rgba(255,77,109,.95)",2,()=>{
          ctx.moveTo(e.x + Math.cos(a)*18, e.y + Math.sin(a)*18);
          ctx.lineTo(e.x + Math.cos(a+2.6)*14, e.y + Math.sin(a+2.6)*14);
          ctx.lineTo(e.x + Math.cos(a+Math.PI)*8, e.y + Math.sin(a+Math.PI)*8);
          ctx.lineTo(e.x + Math.cos(a-2.6)*14, e.y + Math.sin(a-2.6)*14);
          ctx.closePath();
        });
      }
      if(e.kind==="mine"){
        const col = (e.arm<=0) ? "rgba(255,209,102,.98)" : "rgba(185,247,255,.9)";
        vstroke(col,2,()=>{ ctx.arc(e.x,e.y,16,0,TAU); });
      }
    }

    // boss
    if(boss){
      vstroke("rgba(185,247,255,.95)",2,()=>{ ctx.roundRect(boss.x-86,boss.y-34,172,78,20); });
      vstroke("rgba(255,209,102,.95)",2,()=>{ ctx.roundRect(boss.x-62,boss.y+10,24,18,6); });
      vstroke("rgba(255,209,102,.95)",2,()=>{ ctx.roundRect(boss.x+38,boss.y+10,24,18,6); });
      const open = bossCoreOpen(boss);
      vstroke(open ? "rgba(127,255,212,.98)" : "rgba(127,255,212,.45)", 2, ()=>{ ctx.arc(boss.x, boss.y+10, 18, 0, TAU); });

      const barW=260, bx=W/2-barW/2, by=34;
      ctx.fillStyle="rgba(185,247,255,.10)";
      ctx.fillRect(bx,by,barW,10);
      const f=clamp(boss.hp/boss.maxHp,0,1);
      ctx.fillStyle="rgba(255,77,109,.45)";
      ctx.fillRect(bx,by,barW*f,10);
      vstroke("rgba(185,247,255,.35)",1,()=>{ ctx.rect(bx+0.5,by+0.5,barW-1,10-1); });
    }

    // bullets
    for(const b of bullets){
      ctx.fillStyle = b.friendly ? "rgba(185,247,255,.95)" : "rgba(255,77,109,.95)";
      ctx.beginPath(); ctx.arc(b.x, b.y, b.r, 0, TAU); ctx.fill();
    }

    // powerups
    for(const p of powerups){
      const col = p.kind==="rapid" ? "rgba(255,209,102,.98)" : "rgba(127,255,212,.98)";
      vstroke(col,2,()=>{ ctx.arc(p.x,p.y,p.r,0,TAU); });
      ctx.font="12px ui-monospace, monospace";
      ctx.fillStyle=col;
      ctx.textAlign="center"; ctx.textBaseline="middle";
      ctx.fillText(p.kind==="rapid"?"R":"S", p.x, p.y+0.5);
    }

    // ship
    const flicker = ship.invuln>0 && Math.floor(state.time*14)%2===0;
    if(!flicker){
      const x=ship.x,y=ship.y,a=ship.a,r=ship.r;
      vstroke("rgba(185,247,255,.98)",2,()=>{
        ctx.moveTo(x + Math.cos(a)*r*1.5, y + Math.sin(a)*r*1.5);
        ctx.lineTo(x + Math.cos(a+2.5)*r, y + Math.sin(a+2.5)*r);
        ctx.lineTo(x + Math.cos(a+Math.PI)*r*0.5, y + Math.sin(a+Math.PI)*r*0.5);
        ctx.lineTo(x + Math.cos(a-2.5)*r, y + Math.sin(a-2.5)*r);
        ctx.closePath();
      });

      if(ship.thrust){
        const fx = x - Math.cos(a)*r*1.2;
        const fy = y - Math.sin(a)*r*1.2;
        vstroke("rgba(255,209,102,.98)",2,()=>{
          ctx.moveTo(fx + Math.cos(a+2.6)*6, fy + Math.sin(a+2.6)*6);
          ctx.lineTo(fx - Math.cos(a)*rand(12,18), fy - Math.sin(a)*rand(12,18));
          ctx.lineTo(fx + Math.cos(a-2.6)*6, fy + Math.sin(a-2.6)*6);
        });
      }

      if(ship.invuln>1.0){
        vstroke("rgba(127,255,212,.65)",2,()=>{ ctx.arc(x,y,r*2.05,0,TAU); });
      }
    }

    // HUD
    ctx.fillStyle="rgba(185,247,255,.85)";
    ctx.font="16px ui-monospace, monospace";
    ctx.textAlign="left";
    ctx.fillText(`SCORE ${String(state.score).padStart(6,"0")}`, 18, 28);
    ctx.fillText(`HI ${String(state.hi).padStart(6,"0")}`, 18, 50);
    ctx.fillText(`LVL ${state.level}`, 18, 72);
    ctx.textAlign="right";
    ctx.fillText(`LIVES ${state.lives}`, W-18, 28);

    if(state.time < ship.rapidUntil){
      ctx.fillStyle="rgba(255,209,102,.85)";
      ctx.fillText(`RAPID ${Math.ceil(ship.rapidUntil - state.time)}s`, W-18, 50);
    } else if(ship.invuln>1.0){
      ctx.fillStyle="rgba(127,255,212,.85)";
      ctx.fillText(`SHIELD ${Math.ceil(ship.invuln)}s`, W-18, 50);
    }

    if(state.bannerT>0){
      ctx.globalAlpha = clamp(state.bannerT/1.6,0,1);
      ctx.fillStyle="rgba(0,0,0,.35)";
      ctx.fillRect(0, H*0.12, W, 56);
      ctx.textAlign="center";
      ctx.textBaseline="middle";
      ctx.font="22px ui-monospace, monospace";
      ctx.fillStyle = state.mode==="boss" ? "rgba(255,77,109,.9)" : "rgba(185,247,255,.9)";
      ctx.fillText(state.mode==="boss" ? "BOSS ROUND" : "WAVE INCOMING", W/2, H*0.12+28);
      ctx.globalAlpha = 1;
    }

    ctx.restore();

    // decay shake (fixed step)
    state.shake = Math.max(0, state.shake - 0.9*(1/60));
  }

  // ===== Loop
  let last = performance.now();
  function loop(now){
    const dt = Math.min(0.033, (now-last)/1000);
    last = now;
    if(!state.paused) update(dt);
    draw();
    requestAnimationFrame(loop);
  }

  // ===== Start on splash
  resetShip();
  bullets=[]; rocks=[]; enemies=[]; powerups=[]; particles=[]; boss=null;
  showSplash = true;
  state.mode="splash";
  requestAnimationFrame(loop);

})();
</script>
</body>
</html>
